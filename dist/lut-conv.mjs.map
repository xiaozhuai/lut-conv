{"version":3,"sources":["../src/lut-conv.ts"],"sourcesContent":["type LutConvFilterMode = 'nearest' | 'linear';\n\nfunction clamp(value: number, min: number, max: number): number {\n    return Math.max(min, Math.min(max, value));\n}\n\nfunction lerp(a: number, b: number, t: number): number {\n    return a + t * (b - a);\n}\n\nexport class LutData {\n    width: number;\n    height: number;\n    depth: number;\n    data: Float32Array;\n\n    /**\n     * Create a new LutData\n     * @param width\n     * @param height\n     * @param depth\n     * @param data Initial data, null means create a new data array\n     */\n    constructor(width: number, height: number, depth: number, data: Float32Array | null = null) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        if (data === null) {\n            this.data = new Float32Array(width * height * depth * 3);\n        } else {\n            if (data.length !== width * height * depth * 3) {\n                throw new Error(\"Invalid data length\");\n            }\n            this.data = data;\n        }\n    }\n\n    /**\n     * Get the value at the specified index\n     * @param x Range [0, width)\n     * @param y Range [0, height)\n     * @param z Range [0, depth)\n     */\n    get(x: number, y: number, z: number): Float32Array {\n        const i = (z * this.width * this.height + y * this.width + x) * 3;\n        return this.data.subarray(i, i + 3);\n    }\n\n    /**\n     * Set the value at the specified index\n     * @param x Range [0, width)\n     * @param y Range [0, height)\n     * @param z Range [0, depth)\n     * @param value\n     */\n    set(x: number, y: number, z: number, value: Float32Array): void {\n        const i = (z * this.width * this.height + y * this.width + x) * 3;\n        this.data[i] = value[0];\n        this.data[i + 1] = value[1];\n        this.data[i + 2] = value[2];\n    }\n\n    /**\n     * Lookup value\n     * @param r Range [0, 1]\n     * @param g Range [0, 1]\n     * @param b Range [0, 1]\n     * @param mode Filter mode\n     */\n    lookup(r: number, g: number, b: number, mode: LutConvFilterMode): Float32Array {\n        switch (mode) {\n            case 'nearest':\n                return this.lookupNearest(r, g, b);\n            case 'linear':\n                return this.lookupLinear(r, g, b);\n            default:\n                throw new Error(\"Invalid filter mode\");\n        }\n    }\n\n    /**\n     * Lookup value\n     * @param r Range [0, 1]\n     * @param g Range [0, 1]\n     * @param b Range [0, 1]\n     */\n    lookupNearest(r: number, g: number, b: number): Float32Array {\n        const fx = r * this.width - 0.5;\n        const fy = g * this.height - 0.5;\n        const fz = b * this.depth - 0.5;\n        const x = clamp(Math.round(fx), 0, this.width - 1);\n        const y = clamp(Math.round(fy), 0, this.width - 1);\n        const z = clamp(Math.round(fz), 0, this.width - 1);\n        return this.get(x, y, z);\n    }\n\n    /**\n     * Lookup value\n     * @param r Range [0, 1]\n     * @param g Range [0, 1]\n     * @param b Range [0, 1]\n     */\n    lookupLinear(r: number, g: number, b: number): Float32Array {\n        const fx = r * this.width - 0.5;\n        const fy = g * this.height - 0.5;\n        const fz = b * this.depth - 0.5;\n\n        const x0 = clamp(Math.floor(fx), 0, this.width - 1);\n        const y0 = clamp(Math.floor(fy), 0, this.height - 1);\n        const z0 = clamp(Math.floor(fz), 0, this.depth - 1);\n        const x1 = clamp(x0 + 1, 0, this.width - 1);\n        const y1 = clamp(y0 + 1, 0, this.height - 1);\n        const z1 = clamp(z0 + 1, 0, this.depth - 1);\n\n        const v000 = this.get(x0, y0, z0);\n        const v001 = this.get(x0, y0, z1);\n        const v010 = this.get(x0, y1, z0);\n        const v011 = this.get(x0, y1, z1);\n        const v100 = this.get(x1, y0, z0);\n        const v101 = this.get(x1, y0, z1);\n        const v110 = this.get(x1, y1, z0);\n        const v111 = this.get(x1, y1, z1);\n\n        const dx = fx - x0;\n        const dy = fy - y0;\n        const dz = fz - z0;\n\n        return (new Float32Array(3)).map((_, i) => lerp(\n            lerp(\n                lerp(v000[i], v100[i], dx),\n                lerp(v010[i], v110[i], dx),\n                dy\n            ),\n            lerp(\n                lerp(v001[i], v101[i], dx),\n                lerp(v011[i], v111[i], dx),\n                dy\n            ),\n            dz\n        ));\n    }\n\n    resize(width: number, height: number, depth: number, mode: LutConvFilterMode): LutData {\n        let newLut = new LutData(width, height, depth);\n        for (let z = 0; z < depth; z++) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    let r = (x + 0.5) / width;\n                    let g = (y + 0.5) / height;\n                    let b = (z + 0.5) / depth;\n                    newLut.set(x, y, z, this.lookup(r, g, b, mode));\n                }\n            }\n        }\n        return newLut;\n    }\n}\n\ninterface LutConvImageInfo {\n    imageWidth: number;\n    imageHeight: number;\n\n    width: number;\n    height: number;\n    depth: number;\n}\n\nexport class LutConv {\n    public static loadCubeStr(cubeStr: string): LutData {\n        const REGEX_SIZE = /^LUT_3D_SIZE (\\d+)$/m;\n        const REGEX_VALUE = /^([\\d\\\\.Ee-]+) ([\\d\\\\.Ee-]+) ([\\d\\\\.Ee-]+)$/;\n\n        const resultSize = REGEX_SIZE.exec(cubeStr);\n        if (!resultSize || resultSize.length < 2) {\n            throw new Error(\"Error parsing cube\");\n        }\n        const size = parseInt(resultSize[1]);\n        const lines = cubeStr.replace(/\\r/g, '').split('\\n');\n        let index = 0;\n        while (!REGEX_VALUE.test(lines[index])) {\n            index++;\n        }\n        lines.splice(0, index);\n        lines.splice(size * size * size);\n\n        let data = new Float32Array(size * size * size * 3);\n        lines.forEach((line, i) => {\n            let v = line.split(' ').map(parseFloat);\n            data[i * 3] = v[0];\n            data[i * 3 + 1] = v[1];\n            data[i * 3 + 2] = v[2];\n        });\n        return new LutData(size, size, size, data);\n    }\n\n    public static saveCubeStr(lut: LutData, headers: string = ''): string {\n        if (lut.width !== lut.height || lut.width !== lut.depth) {\n            throw new Error(\"Invalid lut size\");\n        }\n        let cubeStr = `${headers.trim()}\\nLUT_3D_SIZE ${lut.width}\\n\\n`;\n        for (let z = 0; z < lut.depth; z++) {\n            for (let y = 0; y < lut.height; y++) {\n                for (let x = 0; x < lut.width; x++) {\n                    let v = lut.get(x, y, z);\n                    cubeStr += `${v[0].toFixed(6)} ${v[1].toFixed(6)} ${v[2].toFixed(6)}\\n`;\n                }\n            }\n        }\n        return cubeStr;\n    }\n\n    public static loadLutImageData(imageData: Uint8ClampedArray, lutImageInfo: LutConvImageInfo) {\n        const {imageWidth, imageHeight, width, height, depth} = lutImageInfo;\n        if (imageWidth % width !== 0 || imageHeight % height !== 0) {\n            throw new Error(\"Invalid image size\");\n        }\n        const gWidth = imageWidth / width;\n        // const gHeight = imageHeight / height;\n\n        let lut = new LutData(width, height, depth);\n        for (let z = 0; z < depth; z++) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const gx = z % gWidth;\n                    const gy = Math.floor(z / gWidth);\n                    const px = x + gx * width;\n                    const py = y + gy * height;\n                    const i = (py * imageWidth + px) * 4;\n                    lut.set(x, y, z, new Float32Array([\n                        imageData[i] / 255.0,\n                        imageData[i + 1] / 255.0,\n                        imageData[i + 2] / 255.0,\n                    ]));\n                }\n            }\n        }\n        return lut;\n    }\n\n    public static saveLutImageData(lut: LutData, lutImageInfo: LutConvImageInfo): Uint8ClampedArray {\n        const {imageWidth, imageHeight, width, height, depth} = lutImageInfo;\n        if (imageWidth % width !== 0 || imageHeight % height !== 0) {\n            throw new Error(\"Invalid image size\");\n        }\n        if (lut.width !== width || lut.height !== height || lut.depth !== depth) {\n            throw new Error(\"Invalid lut size\");\n        }\n        const gWidth = imageWidth / width;\n        // const gHeight = imageHeight / height;\n\n        let imageData = new Uint8ClampedArray(imageWidth * imageHeight * 4);\n        for (let z = 0; z < depth; z++) {\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const gx = z % gWidth;\n                    const gy = Math.floor(z / gWidth);\n                    const px = x + gx * width;\n                    const py = y + gy * height;\n                    const i = (py * imageWidth + px) * 4;\n                    const v = lut.get(x, y, z);\n                    imageData[i] = clamp(Math.round(v[0] * 255), 0, 255);\n                    imageData[i + 1] = clamp(Math.round(v[1] * 255), 0, 255);\n                    imageData[i + 2] = clamp(Math.round(v[2] * 255), 0, 255);\n                    imageData[i + 3] = 255;\n                }\n            }\n        }\n        return imageData;\n    }\n}\n"],"mappings":"AAEA,SAASA,EAAMC,EAAeC,EAAaC,EAAqB,CAC5D,OAAO,KAAK,IAAID,EAAK,KAAK,IAAIC,EAAKF,CAAK,CAAC,CAC7C,CAEA,SAASG,EAAKC,EAAWC,EAAWC,EAAmB,CACnD,OAAOF,EAAIE,GAAKD,EAAID,EACxB,CAEO,IAAMG,EAAN,MAAMC,CAAQ,CACjB,MACA,OACA,MACA,KASA,YAAYC,EAAeC,EAAgBC,EAAeC,EAA4B,KAAM,CAIxF,GAHA,KAAK,MAAQH,EACb,KAAK,OAASC,EACd,KAAK,MAAQC,EACTC,IAAS,KACT,KAAK,KAAO,IAAI,aAAaH,EAAQC,EAASC,EAAQ,CAAC,MACpD,CACH,GAAIC,EAAK,SAAWH,EAAQC,EAASC,EAAQ,EACzC,MAAM,IAAI,MAAM,qBAAqB,EAEzC,KAAK,KAAOC,CAChB,CACJ,CAQA,IAAIC,EAAWC,EAAWC,EAAyB,CAC/C,IAAMC,GAAKD,EAAI,KAAK,MAAQ,KAAK,OAASD,EAAI,KAAK,MAAQD,GAAK,EAChE,OAAO,KAAK,KAAK,SAASG,EAAGA,EAAI,CAAC,CACtC,CASA,IAAIH,EAAWC,EAAWC,EAAWf,EAA2B,CAC5D,IAAMgB,GAAKD,EAAI,KAAK,MAAQ,KAAK,OAASD,EAAI,KAAK,MAAQD,GAAK,EAChE,KAAK,KAAKG,CAAC,EAAIhB,EAAM,CAAC,EACtB,KAAK,KAAKgB,EAAI,CAAC,EAAIhB,EAAM,CAAC,EAC1B,KAAK,KAAKgB,EAAI,CAAC,EAAIhB,EAAM,CAAC,CAC9B,CASA,OAAOiB,EAAWC,EAAWb,EAAWc,EAAuC,CAC3E,OAAQA,EAAM,CACV,IAAK,UACD,OAAO,KAAK,cAAcF,EAAGC,EAAGb,CAAC,EACrC,IAAK,SACD,OAAO,KAAK,aAAaY,EAAGC,EAAGb,CAAC,EACpC,QACI,MAAM,IAAI,MAAM,qBAAqB,CAC7C,CACJ,CAQA,cAAcY,EAAWC,EAAWb,EAAyB,CACzD,IAAMe,EAAKH,EAAI,KAAK,MAAQ,GACtBI,EAAKH,EAAI,KAAK,OAAS,GACvBI,EAAKjB,EAAI,KAAK,MAAQ,GACtBQ,EAAId,EAAM,KAAK,MAAMqB,CAAE,EAAG,EAAG,KAAK,MAAQ,CAAC,EAC3CN,EAAIf,EAAM,KAAK,MAAMsB,CAAE,EAAG,EAAG,KAAK,MAAQ,CAAC,EAC3CN,EAAIhB,EAAM,KAAK,MAAMuB,CAAE,EAAG,EAAG,KAAK,MAAQ,CAAC,EACjD,OAAO,KAAK,IAAIT,EAAGC,EAAGC,CAAC,CAC3B,CAQA,aAAaE,EAAWC,EAAWb,EAAyB,CACxD,IAAMe,EAAKH,EAAI,KAAK,MAAQ,GACtBI,EAAKH,EAAI,KAAK,OAAS,GACvBI,EAAKjB,EAAI,KAAK,MAAQ,GAEtBkB,EAAKxB,EAAM,KAAK,MAAMqB,CAAE,EAAG,EAAG,KAAK,MAAQ,CAAC,EAC5CI,EAAKzB,EAAM,KAAK,MAAMsB,CAAE,EAAG,EAAG,KAAK,OAAS,CAAC,EAC7CI,EAAK1B,EAAM,KAAK,MAAMuB,CAAE,EAAG,EAAG,KAAK,MAAQ,CAAC,EAC5CI,EAAK3B,EAAMwB,EAAK,EAAG,EAAG,KAAK,MAAQ,CAAC,EACpCI,EAAK5B,EAAMyB,EAAK,EAAG,EAAG,KAAK,OAAS,CAAC,EACrCI,EAAK7B,EAAM0B,EAAK,EAAG,EAAG,KAAK,MAAQ,CAAC,EAEpCI,EAAO,KAAK,IAAIN,EAAIC,EAAIC,CAAE,EAC1BK,EAAO,KAAK,IAAIP,EAAIC,EAAII,CAAE,EAC1BG,EAAO,KAAK,IAAIR,EAAII,EAAIF,CAAE,EAC1BO,EAAO,KAAK,IAAIT,EAAII,EAAIC,CAAE,EAC1BK,EAAO,KAAK,IAAIP,EAAIF,EAAIC,CAAE,EAC1BS,EAAO,KAAK,IAAIR,EAAIF,EAAII,CAAE,EAC1BO,EAAO,KAAK,IAAIT,EAAIC,EAAIF,CAAE,EAC1BW,EAAO,KAAK,IAAIV,EAAIC,EAAIC,CAAE,EAE1BS,EAAKjB,EAAKG,EACVe,EAAKjB,EAAKG,EACVe,EAAKjB,EAAKG,EAEhB,OAAQ,IAAI,aAAa,CAAC,EAAG,IAAI,CAACe,EAAGxB,IAAMb,EACvCA,EACIA,EAAK0B,EAAKb,CAAC,EAAGiB,EAAKjB,CAAC,EAAGqB,CAAE,EACzBlC,EAAK4B,EAAKf,CAAC,EAAGmB,EAAKnB,CAAC,EAAGqB,CAAE,EACzBC,CACJ,EACAnC,EACIA,EAAK2B,EAAKd,CAAC,EAAGkB,EAAKlB,CAAC,EAAGqB,CAAE,EACzBlC,EAAK6B,EAAKhB,CAAC,EAAGoB,EAAKpB,CAAC,EAAGqB,CAAE,EACzBC,CACJ,EACAC,CACJ,CAAC,CACL,CAEA,OAAO9B,EAAeC,EAAgBC,EAAeQ,EAAkC,CACnF,IAAIsB,EAAS,IAAIjC,EAAQC,EAAOC,EAAQC,CAAK,EAC7C,QAASI,EAAI,EAAGA,EAAIJ,EAAOI,IACvB,QAASD,EAAI,EAAGA,EAAIJ,EAAQI,IACxB,QAASD,EAAI,EAAGA,EAAIJ,EAAOI,IAAK,CAC5B,IAAII,GAAKJ,EAAI,IAAOJ,EAChBS,GAAKJ,EAAI,IAAOJ,EAChBL,GAAKU,EAAI,IAAOJ,EACpB8B,EAAO,IAAI5B,EAAGC,EAAGC,EAAG,KAAK,OAAOE,EAAGC,EAAGb,EAAGc,CAAI,CAAC,CAClD,CAGR,OAAOsB,CACX,CACJ,EAWaC,EAAN,KAAc,CACjB,OAAc,YAAYC,EAA0B,CAChD,IAAMC,EAAa,uBACbC,EAAc,8CAEdC,EAAaF,EAAW,KAAKD,CAAO,EAC1C,GAAI,CAACG,GAAcA,EAAW,OAAS,EACnC,MAAM,IAAI,MAAM,oBAAoB,EAExC,IAAMC,EAAO,SAASD,EAAW,CAAC,CAAC,EAC7BE,EAAQL,EAAQ,QAAQ,MAAO,EAAE,EAAE,MAAM;AAAA,CAAI,EAC/CM,EAAQ,EACZ,KAAO,CAACJ,EAAY,KAAKG,EAAMC,CAAK,CAAC,GACjCA,IAEJD,EAAM,OAAO,EAAGC,CAAK,EACrBD,EAAM,OAAOD,EAAOA,EAAOA,CAAI,EAE/B,IAAInC,EAAO,IAAI,aAAamC,EAAOA,EAAOA,EAAO,CAAC,EAClD,OAAAC,EAAM,QAAQ,CAACE,EAAMlC,IAAM,CACvB,IAAImC,EAAID,EAAK,MAAM,GAAG,EAAE,IAAI,UAAU,EACtCtC,EAAKI,EAAI,CAAC,EAAImC,EAAE,CAAC,EACjBvC,EAAKI,EAAI,EAAI,CAAC,EAAImC,EAAE,CAAC,EACrBvC,EAAKI,EAAI,EAAI,CAAC,EAAImC,EAAE,CAAC,CACzB,CAAC,EACM,IAAI5C,EAAQwC,EAAMA,EAAMA,EAAMnC,CAAI,CAC7C,CAEA,OAAc,YAAYwC,EAAcC,EAAkB,GAAY,CAClE,GAAID,EAAI,QAAUA,EAAI,QAAUA,EAAI,QAAUA,EAAI,MAC9C,MAAM,IAAI,MAAM,kBAAkB,EAEtC,IAAIT,EAAU,GAAGU,EAAQ,KAAK,CAAC;AAAA,cAAiBD,EAAI,KAAK;AAAA;AAAA,EACzD,QAASrC,EAAI,EAAGA,EAAIqC,EAAI,MAAOrC,IAC3B,QAASD,EAAI,EAAGA,EAAIsC,EAAI,OAAQtC,IAC5B,QAASD,EAAI,EAAGA,EAAIuC,EAAI,MAAOvC,IAAK,CAChC,IAAIsC,EAAIC,EAAI,IAAIvC,EAAGC,EAAGC,CAAC,EACvB4B,GAAW,GAAGQ,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,IAAIA,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,IAAIA,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;AAAA,CACvE,CAGR,OAAOR,CACX,CAEA,OAAc,iBAAiBW,EAA8BC,EAAgC,CACzF,GAAM,CAAC,WAAAC,EAAY,YAAAC,EAAa,MAAAhD,EAAO,OAAAC,EAAQ,MAAAC,CAAK,EAAI4C,EACxD,GAAIC,EAAa/C,IAAU,GAAKgD,EAAc/C,IAAW,EACrD,MAAM,IAAI,MAAM,oBAAoB,EAExC,IAAMgD,EAASF,EAAa/C,EAGxB2C,EAAM,IAAI7C,EAAQE,EAAOC,EAAQC,CAAK,EAC1C,QAASI,EAAI,EAAGA,EAAIJ,EAAOI,IACvB,QAASD,EAAI,EAAGA,EAAIJ,EAAQI,IACxB,QAASD,EAAI,EAAGA,EAAIJ,EAAOI,IAAK,CAC5B,IAAM8C,EAAK5C,EAAI2C,EACTE,EAAK,KAAK,MAAM7C,EAAI2C,CAAM,EAC1BG,EAAKhD,EAAI8C,EAAKlD,EAEdO,IADKF,EAAI8C,EAAKlD,GACJ8C,EAAaK,GAAM,EACnCT,EAAI,IAAIvC,EAAGC,EAAGC,EAAG,IAAI,aAAa,CAC9BuC,EAAUtC,CAAC,EAAI,IACfsC,EAAUtC,EAAI,CAAC,EAAI,IACnBsC,EAAUtC,EAAI,CAAC,EAAI,GACvB,CAAC,CAAC,CACN,CAGR,OAAOoC,CACX,CAEA,OAAc,iBAAiBA,EAAcG,EAAmD,CAC5F,GAAM,CAAC,WAAAC,EAAY,YAAAC,EAAa,MAAAhD,EAAO,OAAAC,EAAQ,MAAAC,CAAK,EAAI4C,EACxD,GAAIC,EAAa/C,IAAU,GAAKgD,EAAc/C,IAAW,EACrD,MAAM,IAAI,MAAM,oBAAoB,EAExC,GAAI0C,EAAI,QAAU3C,GAAS2C,EAAI,SAAW1C,GAAU0C,EAAI,QAAUzC,EAC9D,MAAM,IAAI,MAAM,kBAAkB,EAEtC,IAAM+C,EAASF,EAAa/C,EAGxB6C,EAAY,IAAI,kBAAkBE,EAAaC,EAAc,CAAC,EAClE,QAAS1C,EAAI,EAAGA,EAAIJ,EAAOI,IACvB,QAASD,EAAI,EAAGA,EAAIJ,EAAQI,IACxB,QAASD,EAAI,EAAGA,EAAIJ,EAAOI,IAAK,CAC5B,IAAM8C,EAAK5C,EAAI2C,EACTE,EAAK,KAAK,MAAM7C,EAAI2C,CAAM,EAC1BG,EAAKhD,EAAI8C,EAAKlD,EAEdO,IADKF,EAAI8C,EAAKlD,GACJ8C,EAAaK,GAAM,EAC7B,EAAIT,EAAI,IAAIvC,EAAGC,EAAGC,CAAC,EACzBuC,EAAUtC,CAAC,EAAIjB,EAAM,KAAK,MAAM,EAAE,CAAC,EAAI,GAAG,EAAG,EAAG,GAAG,EACnDuD,EAAUtC,EAAI,CAAC,EAAIjB,EAAM,KAAK,MAAM,EAAE,CAAC,EAAI,GAAG,EAAG,EAAG,GAAG,EACvDuD,EAAUtC,EAAI,CAAC,EAAIjB,EAAM,KAAK,MAAM,EAAE,CAAC,EAAI,GAAG,EAAG,EAAG,GAAG,EACvDuD,EAAUtC,EAAI,CAAC,EAAI,GACvB,CAGR,OAAOsC,CACX,CACJ","names":["clamp","value","min","max","lerp","a","b","t","LutData","_LutData","width","height","depth","data","x","y","z","i","r","g","mode","fx","fy","fz","x0","y0","z0","x1","y1","z1","v000","v001","v010","v011","v100","v101","v110","v111","dx","dy","dz","_","newLut","LutConv","cubeStr","REGEX_SIZE","REGEX_VALUE","resultSize","size","lines","index","line","v","lut","headers","imageData","lutImageInfo","imageWidth","imageHeight","gWidth","gx","gy","px"]}